Various options
===============

TODO: merge this with usage.tex, make all of this a .tex file (or a .txt/.rst file?)

o) Keep relocation infos in executable for objdump (does not work with patmos-clang -g !)

patmos-clang -Xgold -q -o <binary> ....
patmos-llvm-objdump -r -d <binary> | less


Compiling, Linking
==================

C source files are compiled to bitcode objects by default (patmos-clang -c). To compile .c files
to ELF objects, use patmos-clang -c -fpatmos-emit -obj. 

Assembly files are always compiled to ELF objects. Archive files (.a) can only contain bitcode objects 
or ELF objects, not a mixture of both. Shared libraries (either bitcode or ELF) are not supported.
It is possible to link multiple bitcode files into a single bitcode file and link it like a static library
(compile with patmos-clang --emit-llvm -o lib<name>.bc, link with -l<name>). Bitcode files are always 
fully linked in, even if there is no usage of any of its symbols. Unused symbols are removed in a separate
optimization step.


Compiling single files to objects (using patmos-clang -c|-S)
------------------------------------------------------------

a) Input .c files are compiled to bitcode files by default. Use -fpatmos-emit-obj to compile
   to ELF objects, or -fpatmos-emit-asm to compile to assembly files.

b) Input .s files are compiled to ELF files.


Linking multiple files with patmos-clang (i.e, not using -c or -S)
------------------------------------------------------------------

The compiler driver (patmos-clang) performs the following steps to compile and link multiple input files.

1) All .c input files are compiled to individual bitcode objects. All assembly files are compiled to 
   individual ELF files.

2) If -nostartfiles is not given and the target OS is not RTEMS, crt0 is added as first input file.

3) Depending on the -nodefaultlibs|-noruntimelibs|.. options, the following libraries are added
   after all user provided inputs: -lc (libc), -lpatmos (libgloss), -lrtsf (softfloats), -lrt (runtime).

4) For any of the above libraries, as well as -lm (libm), a lib<libname>syms.o file is added if the library
   is a bitcode library. The lib<x>syms.o files force the linker to pull in functions for which calls might be
   generated by LLC when compiling from bitcode to ELF.

5) All input files and libraries are checked if they are bitcode files/archives or ELF files/archives. All 
   bitcode files are linked into a single bitcode file. ELF files are ignored in this step.

Attention: This means that symbols that are defined in bitcode archives but are used only in ELF input files
   are not linked in! You need to link in a separate bitcode file containing a pseudo use of the required symbols.

6) The resulting bitcode file is optimized and compiled to relocatable ELF. 

Attention: The optimization step removes any symbol from the bitcode that are not used in bitcode.
   If a function is called only in an ELF object, you need to mark the function with __attribute__((used)).

7) The ELF file is linked with the other ELF files and ELF libraries at the position of the first bitcode input file.
   Relocations are resolved and additional symbols are defined. The result is an executable ELF file.

Attention: Since bitcode inputs are linked first in a separate step, the linking order between bitcode files
   and ELF inputs is not (yet) fully preserved. Using -flto does not solve this, since the LTO plugin also
   links all bitcode files first, and only links in the linked bitcode file *after* all ELF inputs!


Disassembling
-------------

To disassemble .bc files, use either 'patmos-llvm-dis <file>.bc' or 'llvm-dis <file>.bc'. 

To disassemble .o ELF files, use patmos-llvm-objdump -d <file>. Add '-r' to show relocation symbols 
(for relocatable ELFs or executables generated with -Xgold -q).

Debugging
=========

Some useful commands for debugging:

# print out executed instructions and the values of their operands 
# starting from some cycle 
pasim -q --debug=<cycle-to-start-printing> --debug-fmt=instr <binary>

# show disassembly of binary
patmos-llvm-objdump -r -d <binary> | less

# compile with debug infos, show source line numbers
patmos-clang -g -o <binary> ...
readelf --debug-dump=decodedline <binary>

# Compile with debugging info: use CFLAGS="-g" for your application, and add
# the following to your build.cfg:

NEWLIB_TARGET_CFLAGS="-g"
COMPILER_RT_CFLAGS="-g"

# Annotate objdump with source line numbes (this is quite slow at the moment)
patmos-llvm-objdump -r -d <binary> | patmos-dwarfdump <binary> | less

# Annotate simulation trace and stack-trace with line numbers
pasim -q --debug=<cycle-to-start-printing> --debug-fmt=instr <binary> 2>log.txt
cat log.txt | patmos-dwarfdump <binary>

